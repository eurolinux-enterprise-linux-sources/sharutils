/*   -*- buffer-read-only: t -*- vi: set ro:
 *  
 *  DO NOT EDIT THIS FILE   (uudecode-opts.c)
 *  
 *  It has been AutoGen-ed  January  6, 2013 at 06:21:38 PM by AutoGen 5.17.2pre2
 *  From the definitions    uudecode-opts.def
 *  and the template file   options
 *
 * Generated from AutoOpts 37:1:12 templates.
 *
 *  AutoOpts is a copyrighted work.  This source file is not encumbered
 *  by AutoOpts licensing, but is provided under the licensing terms chosen
 *  by the uudecode author or copyright holder.  AutoOpts is
 *  licensed under the terms of the LGPL.  The redistributable library
 *  (``libopts'') is licensed under the terms of either the LGPL or, at the
 *  users discretion, the BSD license.  See the AutoOpts and/or libopts sources
 *  for details.
 *
 * The uudecode program is copyrighted and licensed
 * under the following terms:
 *
 *  Copyright (C) 1994-2013 Free Software Foundation, Inc., all rights reserved.
 *  This is free software. It is licensed for use, modification and
 *  redistribution under the terms of the
 *  GNU General Public License, version 3 or later
 *      <http://gnu.org/licenses/gpl.html>
 *
 *  uudecode is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  uudecode is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *  See the GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License along
 *  with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef __doxygen__
#define OPTION_CODE_COMPILE 1
#include "uudecode-opts.h"
#include <sys/types.h>

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>

#ifdef  __cplusplus
extern "C" {
#endif
extern FILE * option_usage_fp;

/* TRANSLATORS: choose the translation for option names wisely because you
                cannot ever change your mind. */
#define zCopyright      (uudecode_opt_strs+0)
#define zLicenseDescrip (uudecode_opt_strs+298)

/*
 *  global included definitions
 */
#include <error.h>
#include <errno.h>
#include <string.h>

#ifndef NULL
#  define NULL 0
#endif

/*
 *  uudecode option static const strings
 */
static char const uudecode_opt_strs[4552] =
/*     0 */ "uudecode (GNU sharutils) 4.13.3\n"
            "Copyright (C) 1994-2013 Free Software Foundation, Inc., all rights reserved.\n"
            "This is free software. It is licensed for use, modification and\n"
            "redistribution under the terms of the\n"
            "GNU General Public License, version 3 or later\n"
            "    <http://gnu.org/licenses/gpl.html>\n\0"
/*   298 */ "uudecode is free software: you can redistribute it and/or modify it under\n"
            "the terms of the GNU General Public License as published by the Free\n"
            "Software Foundation, either version 3 of the License, or (at your option)\n"
            "any later version.\n\n"
            "uudecode is distributed in the hope that it will be useful, but WITHOUT ANY\n"
            "WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n"
            "FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n"
            "details.\n\n"
            "You should have received a copy of the GNU General Public License along\n"
            "with this program.  If not, see <http://www.gnu.org/licenses/>.\n\0"
/*   903 */ "direct output to file\0"
/*   925 */ "OUTPUT_FILE\0"
/*   937 */ "output-file\0"
/*   949 */ "Ignore fchmod(3P) errors\0"
/*   974 */ "IGNORE_CHMOD\0"
/*   987 */ "ignore-chmod\0"
/*  1000 */ "Display extended usage information and exit\0"
/*  1044 */ "help\0"
/*  1049 */ "Extended usage information passed thru pager\0"
/*  1094 */ "more-help\0"
/*  1104 */ "Output version information and exit\0"
/*  1140 */ "version\0"
/*  1148 */ "Save the option state to a config file\0"
/*  1187 */ "save-opts\0"
/*  1197 */ "Load options from a config file\0"
/*  1229 */ "LOAD_OPTS\0"
/*  1239 */ "no-load-opts\0"
/*  1252 */ "no\0"
/*  1255 */ "UUDECODE\0"
/*  1264 */ "uudecode (GNU sharutils) - decode an encoded file - Ver. 4.13.3\n"
            "USAGE:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [ file ... ]\n\0"
/*  1399 */ "$HOME\0"
/*  1405 */ ".sharrc\0"
/*  1413 */ "bug-gnu-utils@gnu.org\0"
/*  1435 */ "\n"
            "If no 'file'(s) are provided, then standard input is decoded.\n\0"
/*  1499 */ "\n"
            "'Uudecode' transforms uuencoded files into their original form.\n\n"
            "The encoded file(s) may be specified on the command line, or one may be\n"
            "read from standard input.  The output file name is specified in the encoded\n"
            "file, but may be overridden with the '-o' option.  It will have the mode of\n"
            "the original file, except that setuid and execute bits are not retained.  If\n"
            "the output file is specified to be '/dev/stdout' or '-', the result will be\n"
            "written to standard output.  If there are multiple input files and the\n"
            "second or subsquent file specifies standard output, the decoded data will\n"
            "be written to the same file as the previous output.  Don't do that.\n\n"
            "'uudecode' ignores any leading and trailing lines.  It looks for a line\n"
            "that starts with \"'begin'\" and proceeds until the end-of-encoding marker is\n"
            "found.  The program determines from the header line of the encoded file\n"
            "which of the two supported encoding schemes was used.\n\0"
/*  2431 */ "uudecode (GNU sharutils) 4.13.3\0"
/*  2463 */ "uudecode (GNU sharutils) - decode an encoded file - Ver. 4.13.3\n"
            "USAGE:  uudecode [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [ file ... ]\n\n"
            "   -o, --output-file=str      direct output to file\n"
            "   -c, --ignore-chmod         Ignore fchmod(3P) errors\n"
            "   -v, --version[=arg]        Output version information and exit\n"
            "   -h, --help                 Display extended usage information and exit\n"
            "   -!, --more-help            Extended usage information passed thru pager\n"
            "   -R, --save-opts[=arg]      Save the option state to a config file\n"
            "   -r, --load-opts=str        Load options from a config file\n"
            "                                - disabled as --no-load-opts\n"
            "                                - may appear multiple times\n\n"
            "Options are specified by doubled hyphens and their name or by a single\n"
            "hyphen and the flag character.\n\n"
            "If no 'file'(s) are provided, then standard input is decoded.\n\n"
            "The following option preset mechanisms are supported:\n"
            " - reading file $HOME/.sharrc\n\n"
            "'Uudecode' transforms uuencoded files into their original form.\n\n"
            "The encoded file(s) may be specified on the command line, or one may be\n"
            "read from standard input.  The output file name is specified in the encoded\n"
            "file, but may be overridden with the '-o' option.  It will have the mode of\n"
            "the original file, except that setuid and execute bits are not retained.  If\n"
            "the output file is specified to be '/dev/stdout' or '-', the result will be\n"
            "written to standard output.  If there are multiple input files and the\n"
            "second or subsquent file specifies standard output, the decoded data will\n"
            "be written to the same file as the previous output.  Don't do that.\n\n"
            "'uudecode' ignores any leading and trailing lines.  It looks for a line\n"
            "that starts with \"'begin'\" and proceeds until the end-of-encoding marker is\n"
            "found.  The program determines from the header line of the encoded file\n"
            "which of the two supported encoding schemes was used.\n\n"
            "please send bug reports to:  bug-gnu-utils@gnu.org\0"
/*  4412 */ "uudecode (GNU sharutils) - decode an encoded file - Ver. 4.13.3\n"
            "USAGE:  uudecode [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [ file ... ]";

/*
 *  output-file option description:
 */
#define OUTPUT_FILE_DESC      (uudecode_opt_strs+903)
#define OUTPUT_FILE_NAME      (uudecode_opt_strs+925)
#define OUTPUT_FILE_name      (uudecode_opt_strs+937)
#define OUTPUT_FILE_FLAGS     (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  ignore-chmod option description:
 */
#define IGNORE_CHMOD_DESC      (uudecode_opt_strs+949)
#define IGNORE_CHMOD_NAME      (uudecode_opt_strs+974)
#define IGNORE_CHMOD_name      (uudecode_opt_strs+987)
#define IGNORE_CHMOD_FLAGS     (OPTST_DISABLED)

/*
 *  Help/More_Help/Version option descriptions:
 */
#define HELP_DESC       (uudecode_opt_strs+1000)
#define HELP_name       (uudecode_opt_strs+1044)
#ifdef HAVE_WORKING_FORK
#define MORE_HELP_DESC  (uudecode_opt_strs+1049)
#define MORE_HELP_name  (uudecode_opt_strs+1094)
#define MORE_HELP_FLAGS (OPTST_IMM | OPTST_NO_INIT)
#else
#define MORE_HELP_DESC  NULL
#define MORE_HELP_name  NULL
#define MORE_HELP_FLAGS (OPTST_OMITTED | OPTST_NO_INIT)
#endif
#ifdef NO_OPTIONAL_OPT_ARGS
#  define VER_FLAGS     (OPTST_IMM | OPTST_NO_INIT)
#else
#  define VER_FLAGS     (OPTST_SET_ARGTYPE(OPARG_TYPE_STRING) | \
                         OPTST_ARG_OPTIONAL | OPTST_IMM | OPTST_NO_INIT)
#endif
#define VER_DESC        (uudecode_opt_strs+1104)
#define VER_name        (uudecode_opt_strs+1140)
#define SAVE_OPTS_DESC  (uudecode_opt_strs+1148)
#define SAVE_OPTS_name  (uudecode_opt_strs+1187)
#define LOAD_OPTS_DESC     (uudecode_opt_strs+1197)
#define LOAD_OPTS_NAME     (uudecode_opt_strs+1229)
#define NO_LOAD_OPTS_name  (uudecode_opt_strs+1239)
#define LOAD_OPTS_pfx      (uudecode_opt_strs+1252)
#define LOAD_OPTS_name     (NO_LOAD_OPTS_name + 3)
/*
 *  Declare option callback procedures
 */
extern tOptProc
    optionBooleanVal,   optionNestedVal,    optionNumericVal,
    optionPagedUsage,   optionPrintVersion, optionResetOpt,
    optionStackArg,     optionTimeDate,     optionTimeVal,
    optionUnstackArg,   optionVendorOption;
static tOptProc
    doOptOutput_File, doUsageOpt;
#define VER_PROC        optionPrintVersion

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 *  Define the uudecode Option Descriptions.
 * This is an array of OPTION_CT entries, one for each
 * option that the uudecode program responds to.
 */
static tOptDesc optDesc[OPTION_CT] = {
  {  /* entry idx, value */ 0, VALUE_OPT_OUTPUT_FILE,
     /* equiv idx, value */ 0, VALUE_OPT_OUTPUT_FILE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OUTPUT_FILE_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --output-file */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptOutput_File,
     /* desc, NAME, name */ OUTPUT_FILE_DESC, OUTPUT_FILE_NAME, OUTPUT_FILE_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 1, VALUE_OPT_IGNORE_CHMOD,
     /* equiv idx, value */ 1, VALUE_OPT_IGNORE_CHMOD,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ IGNORE_CHMOD_FLAGS, 0,
     /* last opt argumnt */ { NULL }, /* --ignore-chmod */
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ IGNORE_CHMOD_DESC, IGNORE_CHMOD_NAME, IGNORE_CHMOD_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_VERSION, VALUE_OPT_VERSION,
     /* equiv idx value  */ NO_EQUIVALENT, VALUE_OPT_VERSION,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ VER_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ VER_PROC,
     /* desc, NAME, name */ VER_DESC, NULL, VER_name,
     /* disablement strs */ NULL, NULL },



  {  /* entry idx, value */ INDEX_OPT_HELP, VALUE_OPT_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, VALUE_OPT_HELP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_IMM | OPTST_NO_INIT, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doUsageOpt,
     /* desc, NAME, name */ HELP_DESC, NULL, HELP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_MORE_HELP, VALUE_OPT_MORE_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, VALUE_OPT_MORE_HELP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MORE_HELP_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL,  NULL,
     /* option proc      */ optionPagedUsage,
     /* desc, NAME, name */ MORE_HELP_DESC, NULL, MORE_HELP_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_SAVE_OPTS, VALUE_OPT_SAVE_OPTS,
     /* equiv idx value  */ NO_EQUIVALENT, VALUE_OPT_SAVE_OPTS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_SET_ARGTYPE(OPARG_TYPE_STRING)
                          | OPTST_ARG_OPTIONAL | OPTST_NO_INIT, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL,  NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ SAVE_OPTS_DESC, NULL, SAVE_OPTS_name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_LOAD_OPTS, VALUE_OPT_LOAD_OPTS,
     /* equiv idx value  */ NO_EQUIVALENT, VALUE_OPT_LOAD_OPTS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, NOLIMIT, 0,
     /* opt state flags  */ OPTST_SET_ARGTYPE(OPARG_TYPE_STRING)
			  | OPTST_DISABLE_IMM, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionLoadOpt,
     /* desc, NAME, name */ LOAD_OPTS_DESC, LOAD_OPTS_NAME, LOAD_OPTS_name,
     /* disablement strs */ NO_LOAD_OPTS_name, LOAD_OPTS_pfx }
};


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Define the uudecode Option Environment
 */
#define zPROGNAME       (uudecode_opt_strs+1255)
#define zUsageTitle     (uudecode_opt_strs+1264)
#define zRcName         (uudecode_opt_strs+1405)
static char const * const apzHomeList[2] = {
    uudecode_opt_strs+1399,
    NULL };
#define zBugsAddr       (uudecode_opt_strs+1413)
#define zExplain        (uudecode_opt_strs+1435)
#define zDetail         (uudecode_opt_strs+1499)
#define zFullVersion    (uudecode_opt_strs+2431)
/* extracted from optcode.tlib near line 353 */

#if defined(ENABLE_NLS)
# define OPTPROC_BASE OPTPROC_TRANSLATE
  static tOptionXlateProc translate_option_strings;
#else
# define OPTPROC_BASE OPTPROC_NONE
# define translate_option_strings NULL
#endif /* ENABLE_NLS */


#define uudecode_full_usage (uudecode_opt_strs+2463)

#define uudecode_short_usage (uudecode_opt_strs+4412)

#endif /* not defined __doxygen__ */

/*
 *  Create the static procedure(s) declared above.
 */
/**
 * The callout function that invokes the optionUsage function.
 *
 * @param pOptions the AutoOpts option description structure
 * @param pOptDesc the descriptor for the "help" (usage) option.
 * @noreturn
 */
static void
doUsageOpt(tOptions * pOptions, tOptDesc * pOptDesc)
{
    optionUsage(&uudecodeOptions, UUDECODE_EXIT_SUCCESS);
    /* NOTREACHED */
    (void)pOptDesc;
    (void)pOptions;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/**
 * Code to handle the output-file option.
 *
 * @param pOptions the uudecode options data structure
 * @param pOptDesc the option descriptor for this option.
 */
static void
doOptOutput_File(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /*
     * Be sure the flag-code[0] handles special values for the options pointer
     * viz. (poptions <= OPTPROC_EMIT_LIMIT) *and also* the special flag bit
     * ((poptdesc->fOptState & OPTST_RESET) != 0) telling the option to
     * reset its state.
     */
    /* extracted from uudecode-opts.def, line 60 */
  FILE * fp = freopen (pOptDesc->optArg.argString, "w", stdout);
  if (fp != stdout)
    {
      error (0, errno, "%s", pOptDesc->optArg.argString);
      exit (UUDECODE_EXIT_NO_OUTPUT);
    }
    (void)pOptions;
}
/* extracted from optmain.tlib near line 1196 */

/**
 * Print a usage message with a format and va_list argument.
 * The optionUsage function is then invoked to print
 * the error usage text (somewhat abbreviated) and then exit.
 *
 * @param[in] fmt the message format string
 * @param[in] ap  the var-arg list.
 * @noreturn
 */
void
vusage_message(char const * fmt, va_list ap)
{
    char const * er_leader = _("uudecode usage error:\n");
    fputs(er_leader, stderr);
    vfprintf(stderr, fmt, ap);
    optionUsage(&uudecodeOptions, UUDECODE_EXIT_USAGE_ERROR);
    /* NOTREACHED */
}

/**
 * Print a usage message with a format and a variable argument list.
 * vusage_message() is called to do the work.
 *
 * @param[in] fmt the message format string
 * @param[in] ... the argument list for the message
 * @noreturn
 */
void
usage_message(char const * fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    vusage_message(fmt, ap);
    /* NOTREACHED */
    va_end(ap);
}

/**
 * Print a fatal error message and die
 *
 * @param[in] exit_code  the value to call exit(3) with
 * @param[in] fmt        the death rattle message
 * @param[in] ap         the argument list for the message
 * @noreturn
 */
void
vdie(int exit_code, char const * fmt, va_list ap)
{
    char const * die_leader = _("uudecode fatal error:\n");
    fputs(die_leader, stderr);
    vfprintf(stderr, fmt, ap);
    fflush(stderr);
    exit(exit_code);
    /* NOTREACHED */
}

/**
 * Print a fatal error message and die
 *
 * @param[in] exit_code  the value to call exit(3) with
 * @param[in] fmt        the death rattle message
 * @param[in] ...        the list of arguments for the message
 * @noreturn
 */
void
die(int exit_code, char const * fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    vdie(exit_code, fmt, ap);
    /* NOTREACHED */
    va_end(ap);
}

/**
 * Print a file system error fatal error message and die
 *
 * @param[in] exit_code  the value to call exit(3) with.
 * @param[in] op         the operation that failed.
 * @param[in] fname      the file name the operation was on.
 * @noreturn
 */
void
fserr(int exit_code, char const * op, char const * fname)
{
    char const * fserr_fmt = _("fserr %d (%s) performing '%s' on %s\n");
    die(exit_code, fserr_fmt, errno, strerror(errno), op, fname);
    /* NOTREACHED */
}

/**
 * The directory containing the data associated with uudecode.
 */
#ifndef  PKGDATADIR
# define PKGDATADIR ""
#endif

/**
 * Information about the person or institution that packaged uudecode
 * for the current distribution.
 */
#ifndef  WITH_PACKAGER
# define uudecode_packager_info NULL
#else
static char const uudecode_packager_info[] =
    "Packaged by " WITH_PACKAGER

# ifdef WITH_PACKAGER_VERSION
        " ("WITH_PACKAGER_VERSION")"
# endif

# ifdef WITH_PACKAGER_BUG_REPORTS
    "\nReport uudecode bugs to " WITH_PACKAGER_BUG_REPORTS
# endif
    "\n";
#endif
#ifndef __doxygen__

#endif /* __doxygen__ */
/**
 * The option definitions for uudecode.  The one structure that
 * binds them all.
 */
tOptions uudecodeOptions = {
    OPTIONS_STRUCT_VERSION,
    0, NULL,                    /* original argc + argv    */
    ( OPTPROC_BASE
    + OPTPROC_ERRSTOP
    + OPTPROC_SHORTOPT
    + OPTPROC_LONGOPT
    + OPTPROC_NO_REQ_OPT
    + OPTPROC_GNUUSAGE
    + OPTPROC_MISUSE ),
    0, NULL,                    /* current option index, current option */
    NULL,         NULL,         zPROGNAME,
    zRcName,      zCopyright,   zLicenseDescrip,
    zFullVersion, apzHomeList,  zUsageTitle,
    zExplain,     zDetail,      optDesc,
    zBugsAddr,                  /* address to send bugs to */
    NULL, NULL,                 /* extensions/saved state  */
    optionUsage, /* usage procedure */
    translate_option_strings,   /* translation procedure */
    /*
     *  Indexes to special options
     */
    { INDEX_OPT_MORE_HELP, /* more-help option index */
      INDEX_OPT_SAVE_OPTS, /* save option index */
      NO_EQUIVALENT, /* '-#' option index */
      NO_EQUIVALENT /* index of default opt */
    },
    7 /* full option count */, 2 /* user option count */,
    uudecode_full_usage, uudecode_short_usage,
    NULL, NULL,
    PKGDATADIR, uudecode_packager_info
};

#if ENABLE_NLS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#ifdef HAVE_DCGETTEXT
# include <gettext.h>
#endif
#include <autoopts/usage-txt.h>

static char * AO_gettext(char const * pz);
static void   coerce_it(void ** s);

/**
 * AutoGen specific wrapper function for gettext.  It relies on the macro _()
 * to convert from English to the target language, then strdup-duplicates the
 * result string.  It tries the "libopts" domain first, then whatever has been
 * set via the \a textdomain(3) call.
 *
 * @param[in] pz the input text used as a lookup key.
 * @returns the translated text (if there is one),
 *   or the original text (if not).
 */
static char *
AO_gettext(char const * pz)
{
    char * res;
    if (pz == NULL)
        return NULL;
#ifdef HAVE_DCGETTEXT
    /*
     * While processing the option_xlateable_txt data, try to use the
     * "libopts" domain.  Once we switch to the option descriptor data,
     * do *not* use that domain.
     */
    if (option_xlateable_txt.field_ct != 0) {
        res = dgettext("libopts", pz);
        if (res == pz)
            res = (char *)(void *)_(pz);
    } else
        res = (char *)(void *)_(pz);
#else
    res = (char *)(void *)_(pz);
#endif
    if (res == pz)
        return res;
    res = strdup(res);
    if (res == NULL) {
        fputs(_("No memory for duping translated strings\n"), stderr);
        exit(UUDECODE_EXIT_OPTION_ERROR);
    }
    return res;
}

/**
 * All the pointers we use are marked "* const", but they are stored in
 * writable memory.  Coerce the mutability and set the pointer.
 */
static void coerce_it(void ** s) { *s = AO_gettext(*s);
}

/**
 * Translate all the translatable strings in the uudecodeOptions
 * structure defined above.  This is done only once.
 */
static void
translate_option_strings(void)
{
    tOptions * const opts = &uudecodeOptions;

    /*
     *  Guard against re-translation.  It won't work.  The strings will have
     *  been changed by the first pass through this code.  One shot only.
     */
    if (option_xlateable_txt.field_ct != 0) {
        /*
         *  Do the translations.  The first pointer follows the field count
         *  field.  The field count field is the size of a pointer.
         */
        tOptDesc * od = opts->pOptDesc;
        char **    ppz = (char**)(void*)&(option_xlateable_txt);
        int        ix  = option_xlateable_txt.field_ct;

        do {
            ppz++; /* skip over field_ct */
            *ppz = AO_gettext(*ppz);
        } while (--ix > 0);
        /* prevent re-translation and disable "libopts" domain lookup */
        option_xlateable_txt.field_ct = 0;

        coerce_it((void*)&(opts->pzCopyright));
        coerce_it((void*)&(opts->pzCopyNotice));
        coerce_it((void*)&(opts->pzFullVersion));
        coerce_it((void*)&(opts->pzUsageTitle));
        coerce_it((void*)&(opts->pzExplain));
        coerce_it((void*)&(opts->pzDetail));
        coerce_it((void*)&(opts->pzPackager));
        coerce_it((void*)&(opts->pzFullUsage));
        coerce_it((void*)&(opts->pzShortUsage));

        for (ix = opts->optCt; ix > 0; ix--, od++)
            coerce_it((void*)&(od->pzText));
    }

    if ((opts->fOptSet & OPTPROC_NXLAT_OPT_CFG) == 0) {
        tOptDesc * od = opts->pOptDesc;
        int        ix;

        for (ix = opts->optCt; ix > 0; ix--, od++) {
            coerce_it((void*)&(od->pz_Name));
            coerce_it((void*)&(od->pz_DisableName));
            coerce_it((void*)&(od->pz_DisablePfx));
        }
        uudecodeOptions.fOptSet |= OPTPROC_NXLAT_OPT_CFG | OPTPROC_NXLAT_OPT;
    }
}

#endif /* ENABLE_NLS */

#ifdef DO_NOT_COMPILE_THIS_CODE_IT_IS_FOR_GETTEXT
static void bogus_function(void) {

  /* prog-title */
  puts(_("decode an encoded fil"));
  /* full-usage */
  puts(_("uudecode (GNU sharutils) - decode an encoded file - Ver. 4.13.3\n\
USAGE:  uudecode [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [ file ... ]\n\n\
   -o, --output-file=str      direct output to file\n\
   -c, --ignore-chmod         Ignore fchmod(3P) errors\n\
   -v, --version[=arg]        Output version information and exit\n\
   -h, --help                 Display extended usage information and exit\n\
   -!, --more-help            Extended usage information passed thru pager\n\
   -R, --save-opts[=arg]      Save the option state to a config file\n\
   -r, --load-opts=str        Load options from a config file\n\
                                - disabled as --no-load-opts\n\
                                - may appear multiple times\n\n\
Options are specified by doubled hyphens and their name or by a single\n\
hyphen and the flag character.\n\n\
If no 'file'(s) are provided, then standard input is decoded.\n\n\
The following option preset mechanisms are supported:\n\
 - reading file $HOME/.sharrc\n\n\
'Uudecode' transforms uuencoded files into their original form.\n\n\
The encoded file(s) may be specified on the command line, or one may be\n\
read from standard input.  The output file name is specified in the encoded\n\
file, but may be overridden with the '-o' option.  It will have the mode of\n\
the original file, except that setuid and execute bits are not retained.  If\n\
the output file is specified to be '/dev/stdout' or '-', the result will be\n\
written to standard output.  If there are multiple input files and the\n\
second or subsquent file specifies standard output, the decoded data will\n\
be written to the same file as the previous output.  Don't do that.\n\n\
'uudecode' ignores any leading and trailing lines.  It looks for a line\n\
that starts with \"'begin'\" and proceeds until the end-of-encoding marker is\n\
found.  The program determines from the header line of the encoded file\n\
which of the two supported encoding schemes was used.\n\n\
please send bug reports to:  bug-gnu-utils@gnu.org"));
  /* short-usage */
  puts(_("uudecode (GNU sharutils) - decode an encoded file - Ver. 4.13.3\n\
USAGE:  uudecode [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [ file ... ]"));
  /* explain */
  puts(_("If no 'file'(s) are provided, then standard input is decoded"));
  /* detail */
  puts(_("'Uudecode' transforms uuencoded files into their original form.\n\n\
The encoded file(s) may be specified on the command line, or one may be\n\
read from standard input.  The output file name is specified in the encoded\n\
file, but may be overridden with the '-o' option.  It will have the mode of\n\
the original file, except that setuid and execute bits are not retained.  If\n\
the output file is specified to be '/dev/stdout' or '-', the result will be\n\
written to standard output.  If there are multiple input files and the\n\
second or subsquent file specifies standard output, the decoded data will\n\
be written to the same file as the previous output.  Don't do that.\n\n\
'uudecode' ignores any leading and trailing lines.  It looks for a line\n\
that starts with \"'begin'\" and proceeds until the end-of-encoding marker is\n\
found.  The program determines from the header line of the encoded file\n\
which of the two supported encoding schemes was used"));
  /* copyright.type */
  puts(_("This program is released under the terms of the GNU General Public License, version 3 or later."));
}
#endif /* uncompilable code */
#ifdef  __cplusplus
}
#endif
/* uudecode-opts.c ends here */
